# Базовый синтаксис

Сервисы <https://repl.it> и <http://clojurescript.io> позволят вам поэкспериментировать с языком прямо в браузере, без установки окружения на свой компьютер.

Цель этих примеров — научиться читать, но не писать код на clojure.

```clojure
;; комментарий
```

Печать на экран. `prn` - функция печати на экран. `"hello world"` - строка, аргумент функции.

```clojure
(prn "hello world")
```

В lisp используется только префиксная (польская) нотация,
т.е. вызов функции стоит всегда на первом месте, а за ней — ее аргументы.
Вместо функции может быть *специальная форма* или *макрос*, но мы не будем касаться этой темы.
Иными словами на первом месте внутри скобок находится нечто, что будет вызвано (*callable*).

Для примера сравним js и lisp:

```
x.method(y, z) -> (method x y z)
func(x, y, z) -> (func x y z)
x + y -> (+ x y)
```

В Clojure есть поддержка неймспейсов.
Мы не будем разбирать их объявление, а сразу перейдем к вызову:

```clojure
(some-ns/some-fn some-arg)
```

Clojure - язык не ленивый, и аргументы функции вычисляются до ее вызова.
Рассмотрим на примере:

```clojure
(prn (str "hello" " " "world"))
```

Сначала будет вычислен аргумент функции `prn` - `(str "hello" " " "world")`.
`str` — функция сложения (конкатенации) строк.
Таким образом `prn` будет вызван так: `(prn "hello world")`.

Для демонстрации языка воспользуемся утверждениями — `assert`.
Если аргумент ложный, то будет брошено исключение,
если истинный, — просто вернется `nil`.

```clojure
(assert true) ;; #=> nil
;; (assert false) ;; AssertionError Assert failed: false
;; (assert nil)   ;; AssertionError Assert failed: nil
```

Например, я утверждаю, что 1 = 1:
```clojure
(assert (= 1 1))
```

Привычные операторы могут принимать переменное количество аргументов:

```clojure
(assert (= 1)) ;; всегда истинно для одного аргумента
(assert (= 1 1 1)) ;; 1 = 1 = 1

(assert (< 1)) ;; всегда истинно для одного аргумента
(assert (< 1 2 3)) ;; 1 < 2 < 3
```

Примитивные Clojure типы - java типы.
Проверим это с помощью функции `class`, возвращающей класс своего аргумента

```clojure
(assert (= java.lang.String  (class "some string")))
(assert (= java.lang.Long    (class 1)))
(assert (= java.lang.Boolean (class true)))
```

Мы можем задать название некоторому значению с помощью специальной формы `let`:

```clojure
(let [x 1]
  (assert (= 1 x)))
```
Отмечу, что `x` локальное обозначение, и вне `let` оно не существует.


Новое значение можно связать с тем же названием:

```clojure
(let [x 1
      x 2]
  (assert (= 2 x)))
```

Или переопределить внешнее:

```clojure
(let [+ -]
  (assert (= 0 (+ 1 1))))
```

В рамках текущего пространства имен можно объявить глобальное значение:

```clojure
(def x 1)
(assert (= 1 x))
```

Определим анонимную функцию одного аргумента `x` и прибавляющую к нему единицу:

```clojure
(let [f (fn [x] (+ 1 x))]
  (assert (= 3 (f 2))))
```

Если мы хотим объявить функцию в пространстве имен, вместо `(def f (fn [x] ...))` удобно воспользоваться
макросом `defn`:

```clojure
(defn f [x] (+ 1 x))
(assert (= 3 (f 2)))
```

Clojure поддерживает замыкания:

```clojure
(let [x 1
      f (fn [y] (+ x y))]
  (assert (= 3 (f 2))))
```

Функции — это значения:

```clojure
;; `+` - функция, а не оператор
(assert (= 6 (reduce + [0 1 2 3])))
```

Для коротких функций есть краткая форма:

```clojure
(let [x [0 1 2]
      x'  (map #(+ 2 %) x)
      x'' (map (fn [i] (+ 2 i)) x)]
  (assert (= x' x'')))
```

В отличие от императивных языков, в Сlojure нет присваивания,
т.е. `let` не создает переменные, а только именует значения.
Если бы это было присваивание, то функция `f` вернула бы 2:

```clojure
(let [x 1
      f (fn [] x) ;; замыкание(closure)
      x 2]
  (assert (= 2 x))
  (assert (= 1 (f))))
```

Имена могут содержать некоторые спецсимволы и их комбинации:

```clojure
(let [x 1
      x' x
      x? x
      ?x x
      x! x
      !x x
      +x+ x
      -x- x
      *x* x
      =x= x]
  (assert (= x x' x? ?x x! !x +x+ -x- *x* =x=)))
```

Массивы в Clojure называются векторами.
Вектора поддерживают доступ по индексу и
хранят произвольные типы:

```clojure
(let [x [0 "str" true [1 2 3]]]
  (assert (= "str" (get x 1)))
  (assert (= 0 (first x)))
  (assert (= "str" (second x))))
```

Ассоциативные массивы (хеши) или мапы (maps)
хранят ключи и значения произвольных типов.
Запятая в Clojure — просто пробельный символ, который можно опускать,
однако при записи хеша для удобства запятые используют для разделения
пар ключ-значение:

```clojure
(let [x {:key 1, "key" 2, 2 3, true "4", [1 2] "5", nil 6}]
  (assert (= 1 (get x :key)))
  (assert (= 6 (get x nil))))
```

`:key` - это специальный тип Keyword.
Их частно используют как ключи в ассоциативных массивах.
Аналог *символов* в Ruby или *атомов* в Erlang.
Реализуют интерфейс функций, т.е. принимают map и возвращают ассоциированное с собой значение:

```clojure
(let [x {:key "value"}]
  (assert (= "value" (:key x))))
```

Все Сlojure-значения — неизменяемые.
При изменении возвращается новый объект, старый остается доступен.
При этом не происходит полного копирования,
т.е. новая структура переиспользует старую.

```clojure
;; pop - возвращает коллекцию без вершины
(let [x  [0 1 2 3]
      x' (pop x)]
  (assert (= [0 1 2 3] x))
  (assert (= [0 1 2] x')))

;; assoc - добавляет значения по их ключам
(let [x {}
      x' (assoc x :k1 1 :k2 2)]
  (assert (= {} x))
  (assert (= {:k1 1, :k2 2} x')))
```

Этот код можно выполнить [прямо в браузере](https://repl.it/@darkleaf/clojure-tour).
Там доступна консоль, в которой можно выполнять произвольные выражения Clojure.
